<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.20-13.8smp i686) [Netscape]">
</head>
<body>

<CENTER><H1><b>TextTest User Guide</b></H1></CENTER>

<H2><b>The framework</b></H2>

<H3>The purpose and philosophy</H3>

<p>
TextTest is an application-independent configurable framework for text-based
functional testing,
primarily regression and performance, but also stress testing. It is
written in Python, and comes
with many different configurations. These configurations can add features
of their own, and need to be
documented separately. This document will only document the core framework.
</p>

<p>TextTest is not designed for unit testing. If you want to do unit testing,
look at JUnit and similar products.</p>
<p>The expectation is that tests are written, run and configured using
simple text files only, and that
information in the file system itself is used wherever possible. New
configurations should only need to be
written for new applications, and similar applications may well use
the same configuration. It is <i>not</i>
intended that new code should need to be written when a new test is
created.</p>
<p>To be tested using TextTest, an application needs to be runnable from
the command line using
standard options and/or information in standard input. It needs to
be runnable in batch mode so that
fully automatic tests can be created. It also needs to produce meaningful
output that is, or can be converted
to plain text. It will then use this text to monitor and control the
behaviour of the application.</p>
<H3>The Root Directory</H3>
<p>This is the first thing determined by TextTest on being called, and
is where in your file system it will
start to look for tests. It is determined as follows:
<ol><li> If the command line option "-d" has been set, use the value of
that.
<li> If not, but the environment variable "TEXTTEST_HOME" is set, use
that.
<li> If neither of the above, use the current working directory.
</ol></p>

<H3>Applications</H3>

<p>To test an application under TextTest, the first thing to do is to
choose a unique identifier to be
used as an extension for all files relevant to that application. It
does not matter what this is. For the
next few paragraphs this variable is indicated by &lt;app>.
Basic information about an application and how to run it appears in
a file called "config.&lt;app>". TextTest
will look for files with names of this format to determine which applications
it will run. It will start at the root
directory and look in that directory and one level down in the directory
structure, and all files
beginning with "config." are considered. This file is written in <a href="#Appendix - TextTest file formats">Standard
Dictionary Format</a>, and its contents
will vary depending on the configuration used.</p>
<p>To tell TextTest to run just one particular application, specify "-a
&lt;app>" on the command line.</p>
<H3>Configurations</H3>
<p>A configuration is a Python module which determines what TextTest will
do. This is important to bear
in mind. TextTest does not, on its own, do anything. It interprets
a directory structure and the files in it
a certain way, and passes these things to its configuration module
to perform actions (such as running
tests and evaluating the results).</p>
<p>In your application's config file, you must therefore specify a configuration
by using the "config_module"
>entry. What this configuration will do is up to the person who wrote
it, and hence in order to find this information out
for a particular application, run "texttest -a &lt;app> -help". This
will ask the configuration to write out what
it does by default and how you can change what it does.</p>
<p>A configuration can both extend the range of command line options available,
and the config file entries that
will be interpreted and acted upon.</p>
<p>TextTest comes with 3 configurations to choose from - "default" which
should work anywhere, "unixConfig" for use
on UNIX, and "lsf" for use on UNIX with LSF from Platform computing
installed. It is expected that you will
want to extend these configurations to take advantage of local circumstances
or to add features that you need.</p>
<H3>User Interfaces</H3>
<p>TextTest is a command line program: all suitable options must be provided
on startup as described by
your configuration. It does however have a GUI for monitoring the tests,
which is enabled by the -g option
and requires PyGTK to be installed (the GUI library). Alternatively
there is a basic text interface provided
by the default configuration, see the configuration help for details.</p>
<p>Using the GUI should be fairly self-explanatory. Double clicking on
tests from the tree view on the left
window will bring up the details of what's going on in that test. Double
clicking on files
from the test view will bring up views of those files, using the config
file entry "diff_program"
for viewing differences, the entry "follow_program" for following a
running test and "view_program"
for viewing a static file. These default to tkdiff, tail -f and xemacs
respectively on UNIX systems. The bottom
right window contains various tabs which allow you to configure viewing
and saving options, etc.</p>

<H3>Test Cases</H3>
<p>A test case is represented in TextTest by a particular directory in
the file system, and the name of the test case
is always the same as the name of the directory. Many applications
may share the same test case if desired.
To define a test case for an application, a file called "options.&lt;app>"
or "input.&lt;app>" must be present.
"options.&lt;app>", if present, will be interpreted as command line
options to be given to the application.</p>
"input.app" will be interpreted as intended for use as standard input.</p>
<p>All files produced when running this test case are written to its directory,
with the .app extension.</p>

<H3>Test Suites</H3>
<p>A Test Suite is a recursive collection of test cases arranged in a
particular order. It is defined for an application
by a directory in the file system containing a local file called "testsuite.&lt;app>".
This file is read by the framework
and lists subdirectories in the order in which they should be considered.
These subdirectories may correspond
to test cases or may themselves be test suites. The file is in <a href="#Appendix - TextTest file formats">Standard
List Format</a>.
TextTest, having found an application "app" by finding config.app, will
then look at testsuite.app in the same
directory to determine what the full test suite consists of.&nbsp;
It will then look, in the order given, at all the subdirectories
specified, and where they are themselves test suites, will repeat this
process recursively until all specified test cases
have been found.</p>

<H3>Setting Environment Variables (using environment files)</H3>
<p>Any test suite or test case can tell TextTest to set environment variables
by providing an environment file.
This is a file called "environment.app" or just "environment" (it has
been found that applications often
need to share environment variables). This file is in&nbsp; <a href="#Appendix - TextTest file formats">Standard
Dictionary Format</a> , with the environment
variable names as keys and their values as entries. If the environment
file is provided in a test case these variables
will be set just for that test case. If in a test suite it will be
set for all test suites and test cases containing in that test suite, operating
recursively.</p>
<p>The values of the variables may themselves contain environment variables:
if so, this should be done in standard UNIX
format using $&lt;var_name>.</p>
<H3>Versions of Applications</H3>
<p>It is often needed to define different versions of an application which
may not be quite the same in all respects, but which
want to share some portion of the test suite structure of the parent
application. To specify a version, use -v &lt;version> on
the command line. For each file type described so far, the framework
will then look also for files called &lt;root>.&lt;app>.&lt;version>
where &lt;root> is environment, config, testsuite etc. in each case.
If such a file does not exist, &lt;root>.&lt;app> is then always used.
If the
file does exist, it is used instead of &lt;root>.&lt;app> in the case
of files in test cases (which are interpreted by the client application)
and
Standard List Format files (i.e. the testsuite.&lt;app> files). In
the case of Standard Dictionary Format (i.e. the config and environment
files),
however, they are interpreted as overriding particular entries in the
dictionary, so that entries not present in &lt;root>.&lt;app>.&lt;version>
are
read from &lt;root>.&lt;app>.</p>
<p>Note that several versions can be "aggregated" and used at the same
time. This is done by specifying -v &lt;version1>.&lt;version2> on the
command line, and can be applied to any number of versions. Note that
the syntax -v &lt;version1>,&lt;version2> is similar to -a &lt;app1>,&lt;app2>:
i.e. it will first run everything with version1 and then run everything
with version2.</p>
<p>You can also say that a version "inherits" settings from another by
adding the "base_version" entry to the config file. Thus if config.&lt;app>.v1
contains the line "base_version:v2" then all the files for v1 are also
read as well as those for v2.</p>
<p>It can be useful to start another version all the time when running
tests, so that -v &lt;version1> behaves like - v &lt;version1>,&lt;version2>
at all
times (or no option behaves like -v ,&lt;version1>). This is achieved
by adding the line "extra_version:v1" to the relevant config file.</p>

<H3>Checkouts of Applications</H3>
<p>It is expected that TextTest test suites will want to be version-controlled,
and hence an easy means of switching between
different "checkouts" of the version-control system is needed. A checkout
is different to a version in that all checkouts
are expected to produce the same results, and making sure that last
night's central checkout does the same as a developer's local
code is an essential part of verifying development work.</p>
<p>There are thus two compulsory entries in the config file, "checkout_location"
and "default_checkout". Unless the -c
option is specified, these two paths will be appended to determine
the checkout. To change the checkout on the
command line, one of two things can happen:
-c &lt;relative path> will set the checkout to the contents of "checkout_location"
appended to &lt;relative path>
-c &lt;absolute path> will set the checkout to &lt;absolute path></p>
<p>Note that the framework, having determined the checkout, will assume
that all dictionary entries in the environment
and config files which are relative path names (contain, but do not
start with,&nbsp; the operating system path separator) are paths relative
to the checkout, and
hence the checkout name will be pre-pended to these before they are
used.</p>

<H3>File Management and Keeping Temporary Files</H3>
<p>Each time you call TextTest, your run is assigned a unique identifier
based on the version, your user name and the time stamp.
All temporary files created will be created under a root temporary
directory with this identifier. The location of this is controlled
by the config file entry "write_tmp_files", and defaults to ~/texttesttmp
on UNIX systems.
When the run finishes, you will be given an opportunity to save any
new results that may have been found. If you do not do this, the
files will be removed when TextTest cleans up the run's temporary directory
structure. This behaviour is different in version 2.1 from
previous versions.</p>
<p>To override this, the command line option -keeptmp will not delete the
run's directory structure so it can be examined manually
after TextTest exits. However, beware! In this mode it will clean up
the run directories of previous runs that it finds. This means
that you cannot run more than one instance of TextTest on the same
application with the same version simultaneously if you are
specifying the -keeptmp flag.</p>
<p>Sometimes additional input files are needed besides standard input for
a test to run. These may be for individual tests
or for groups of tests. You then need to specify the "link_test_path"
config file entry in order for links to be
provided from the test run directories to these files. You can then
refer to a local file of the appropriate name
in your options file, for example. The path may be a file or a directory,
and it will be found anywhere in the test hierarchy
for a particular test.</p>
<p>There is also "copy_test_path", which is useful for directory structures
which a program may want to write to.</p>

<H3>Repeating things</H3>
<p>It can be useful to detect unreliable behaviour to repeat the test
runs several times. To do this, specify -m &lt;number_of_times> on
the command line. This applies whatever your configuration does.</p>

<H2><b>Some simple command-line examples</b></H2>

<p><i>texttest</i>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Runs all applications and
all tests it can find, starting at the current directory
<br><i>texttest -a dip -p</i>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Searches for a file called
"config.dip", and runs that application if found. Do not delete other temporary
files.
<br><i>texttest -d ~/work/MyTests -c /carm/master</i>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run all applications found,
starting at ~/work/MyTests. Use the central checkout /carm/master instead
of my local one
<br><i>texttest -a cas -v 9 -m 3</i>
<br><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>Run all tests for
the application with extension "cas", using version 9 of that application.
Do everything 3 times.</p>

<H3>Real Examples</H3>
<p>TextTest comes with a test
suite for itself. It is recommended that you look around this (or any other
example you can find)
to get an idea of how the program works. It can easily be run via "texttest
-a texttest", and when writing your own tests it is often
best to start with working files for another application and edit them
suitably. This reduces the risk of typing things wrongly,
particularly in the config file.</p>
<p>It works by testing itself testing runs of a target application with
various settings, and verifying correct TextTest behaviour
with success, failures, bad configurations etc. The target application
is itself a toy Python program which adjudicates the popular board
game "Diplomacy".</p>


<H2><a NAME="Appendix - TextTest file formats"></a><b>Appendix - TextTest
file formats</b></H2>
<p>TextTest reads two file formats - Standard List Format and Standard
Dictionary Format. These are designed to be
as human readable as possible.</p>
<p>Both will filter out blank lines and lines beginning with "#", the latter
being interpreted as comments. It's good
practice to use the latter feature to document things about your application
and its tests in the TextTest files themselves.</p>
<p>Both will also expand environment variables, indicated by "$".</p>
<p>Standard List Format is simple: each entry is a complete line. So a
Standard List File is simply interpreted as a list
of the lines in it which are not blank and do not start with "#".</p>
<p>Standard Dictionary Format has entries in the form &lt;variable>:&lt;value>,
where &lt;variable> indicates an environment
variable to be set in the case of the environment file, and a variable
understood by TextTest or its configurations in
the case of the config file.</p>
<p>In the case of the config file, it can be useful to have the value be
a list itself. This is achieved by adding several entries
for the same &lt;variable>. So if we need to set variable V to a list
consisting of A,B, this is done by
<br>V:A
<br>V:B</p>
<p>Where TextTest is itself interpreting the variables it generally expects
either a list or a single value. Its behaviour
will thus be different when that variable is not present. A list value
that is not present will just be understood as an
empty list. A single value that is not present will generally result
in an error and an exit.</p>

</body>
</html>
